#Problem Description:
#We have 3 missionaries and 3 cannibals who need to cross a river. The boat can carry at most two people, and it must always be controlled by at least one person. The constraints are:
#If at any point on either side of the river, the number of cannibals exceeds the number of missionaries, the cannibals will eat the missionaries.
from collections import deque

def is_valid(state):
    missionaries_left, cannibals_left, boat_position = state
    missionaries_right = 3 - missionaries_left
    cannibals_right = 3 - cannibals_left
    
    # Ensure missionaries are not eaten
    if (missionaries_left > 0 and missionaries_left < cannibals_left) or (missionaries_right > 0 and missionaries_right < cannibals_right):
        return False
    return True

def expand_state(state):
    missionaries_left, cannibals_left, boat_position = state
    possible_moves = []

    for move in [(1, 0), (2, 0), (0, 1), (0, 2), (1, 1)]:
        new_m_left = missionaries_left - move[0] if boat_position == 1 else missionaries_left + move[0]
        new_c_left = cannibals_left - move[1] if boat_position == 1 else cannibals_left + move[1]
        new_boat_position = 1 - boat_position  # Toggle boat position
        
        new_state = (new_m_left, new_c_left, new_boat_position)
        
        if 0 <= new_m_left <= 3 and 0 <= new_c_left <= 3 and is_valid(new_state):
            possible_moves.append(new_state)
    
    return possible_moves

def bfs():
    initial_state = (3, 3, 1)  # 3 missionaries, 3 cannibals, boat on left (1 means left)
    goal_state = (0, 0, 0)     # All on the right bank, boat on the right (0 means right)
    
    # Queue for BFS: (state, path)
    queue = deque([(initial_state, [])])
    visited = set()
    visited.add(initial_state)
    
    while queue:
        state, path = queue.popleft()

        # If goal state is reached
        if state == goal_state:
            return path + [state]
        
        # Expand state to find valid next moves
        for new_state in expand_state(state):
            if new_state not in visited:
                visited.add(new_state)
                queue.append((new_state, path + [state]))
    
    return None  # If no solution

def print_solution(path):
    if path:
        print("Solution path:")
        for step in path:
            print(step)
    else:
        print("No solution found")

# Run BFS to solve the problem
solution = bfs()
print_solution(solution)
